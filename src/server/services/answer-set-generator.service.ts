/**
 * Answer Set Generator Service
 * Generates pre-computed answer sets (correct + close) for challenges using AI
 * This runs ONCE during challenge creation to avoid per-guess AI costs
 */

import type { Context } from "@devvit/public-api";
import { BaseService } from "./base.service.js";
import type { Challenge, ChallengeCreate } from "../../shared/models/challenge.types.js";

/**
 * AnswerSet Type
 * Contains arrays of acceptable answers generated by AI
 */
export type AnswerSet = {
    correct: string[];  // Synonyms, paraphrases that mean the same as intended answer
    close: string[];    // Related but not exact matches (broader/narrower concepts)
};

/**
 * Service for generating answer sets using AI
 * Called once per challenge at creation time
 */
export class AnswerSetGeneratorService extends BaseService {
    // Use Gemini 2.5 Flash model (fast and cost-effective for this task)
    private readonly GEMINI_API_URL =
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";
    private readonly MAX_RETRIES = 2;
    private readonly RETRY_DELAY_MS = 1000;

    constructor(context: Context) {
        super(context);
    }

    /**
     * Generate answer set for a challenge using AI
     * @param challenge - The challenge data (before insertion to DB)
     * @returns AnswerSet with correct and close answer arrays
     * @throws Error if AI generation fails after retries
     */
    async generateAnswerSet(
        challenge: ChallengeCreate | Challenge
    ): Promise<AnswerSet> {
        try {
            this.logInfo(
                "AnswerSetGenerator",
                `Generating answer set for: "${challenge.correct_answer}"`
            );

            // Try AI generation with retry logic
            const answerSet = await this.withRetry(
                () => this.generateWithAI(challenge),
                {
                    maxRetries: this.MAX_RETRIES,
                    initialDelayMs: this.RETRY_DELAY_MS,
                    exponentialBackoff: true,
                }
            );

            this.logInfo(
                "AnswerSetGenerator",
                `Generated answer set: ${answerSet.correct.length} correct, ${answerSet.close.length} close`
            );

            return answerSet;
        } catch (error) {
            this.logError(
                "AnswerSetGenerator",
                `AI generation failed: ${error instanceof Error ? error.message : String(error)}`
            );

            // Fall back to basic answer set
            this.logWarning("AnswerSetGenerator", "Using fallback answer set");
            return this.getFallbackAnswerSet(challenge);
        }
    }

    /**
     * Generate answer set using Google Gemini API
     */
    private async generateWithAI(
        challenge: ChallengeCreate | Challenge
    ): Promise<AnswerSet> {
        // Get Gemini API key from settings
        const settings = await this.context.settings.getAll();
        const apiKey = settings["GEMINI_API_KEY"] as string;

        if (!apiKey) {
            this.logError("AnswerSetGenerator", "GEMINI_API_KEY not configured");
            throw new Error("AI generation not configured");
        }

        // Build the prompt
        const systemPrompt = this.buildSystemPrompt();
        const userPrompt = this.buildUserPrompt(challenge);

        // Build request payload with structured output
        const payload = {
            contents: [{ parts: [{ text: userPrompt }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                maxOutputTokens: 2048,
                temperature: 0.7, // Slightly creative for variation generation
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        correct: {
                            type: "ARRAY",
                            items: { type: "STRING" },
                            description: "Array of acceptable correct answers (synonyms, paraphrases)",
                        },
                        close: {
                            type: "ARRAY",
                            items: { type: "STRING" },
                            description: "Array of related but not fully correct answers",
                        },
                    },
                    required: ["correct", "close"],
                },
            },
        };

        // Make API request with timeout
        const url = `${this.GEMINI_API_URL}?key=${apiKey}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout

        let response: Response;
        try {
            response = await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
                signal: controller.signal,
            });
        } catch (fetchError: any) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
                this.logError("AnswerSetGenerator", "API request timed out after 20 seconds");
                throw new Error("API request timed out");
            }
            throw fetchError;
        } finally {
            clearTimeout(timeoutId);
        }

        if (!response.ok) {
            const errorBody = await response.text();
            this.logError(
                "AnswerSetGenerator",
                `API request failed with status ${response.status}: ${errorBody}`
            );
            throw new Error(`API request failed: ${response.status}`);
        }

        // Parse and validate response
        const result = await response.json();
        return this.parseAndValidateResponse(result);
    }

    /**
     * Build the system prompt for AI
     * Tuned for "Game Master" logic with Few-Shot examples
     */
    private buildSystemPrompt(): string {
        return `You are an expert Game Master and Linguist for a 'Guess the Link' word game.
Your goal is to generate a comprehensive JSON Answer Set based on a Target Answer and Context.

### DEFINITIONS
1. **CORRECT List (Win State):**
   - Exact synonyms and paraphrases.
   - Plural/Singular variations (unless number is specific).
   - Regional spellings (Color vs Colour).
   - Common typos or phonetic misspellings (e.g., "vacum" for "vacuum").
   - The player gets points for these.

2. **CLOSE List (Hint State):**
   - Concepts that are "warm" or "hot" but not the answer.
   - Broader categories (Answer: "Apple" -> Close: "Fruit").
   - Narrower specific types (Answer: "Apple" -> Close: "Granny Smith").
   - Component parts or related associations.
   - AVOID: Generic words like "thing", "place", or "object".

### EXAMPLES

Input: Target "Tea", Context "leaves, hot water, british"
Output:
{
  "correct": ["chai", "hot tea", "cup of tea", "cuppa", "herbal tea", "teas"],
  "close": ["coffee", "beverage", "drink", "caffeine", "leaves", "brew", "steep"]
}

Input: Target "Harry Potter", Context "wizard, lightning scar, glasses"
Output:
{
  "correct": ["harry james potter", "the boy who lived", "potter", "harry potter series"],
  "close": ["hogwarts", "wizarding world", "hermione", "ron weasley", "magic", "sorcerer", "jk rowling"]
}

Input: Target "Silence", Context "finger on lips, quiet room"
Output:
{
  "correct": ["silent", "quiet", "hush", "mute", "soundless", "quietness", "silence"],
  "close": ["noise", "sound", "whisper", "library", "peace", "calm", "loud"]
}

### RULES
- Output STRICT JSON only.
- Do NOT include the Target Answer in the lists (the system handles that).
- Ensure "Correct" list has 5-20 items.
- Ensure "Close" list has 5-15 items.
- Lowercase everything.`;
    }

    /**
     * Build the user prompt with challenge data
     */
    private buildUserPrompt(challenge: ChallengeCreate | Challenge): string {
        const descriptions = challenge.image_descriptions || [];
        const imageContext = descriptions.length > 0
            ? descriptions.map((d, i) => `Image ${i + 1}: ${d}`).join("; ")
            : "No specific images provided";

        const explanation = challenge.answer_explanation || "No explanation provided";

        // Explicitly label the input components to match the System Prompt structure
        return `Target Answer: "${challenge.correct_answer}"
Context Images: ${imageContext}
Creator Context: ${explanation}`;
    }

    /**
     * Parse and validate the AI response
     */
    private parseAndValidateResponse(result: any): AnswerSet {
        const candidate = result?.candidates?.[0];

        if (!candidate) {
            this.logError("AnswerSetGenerator", "No candidates returned from API");
            throw new Error("Invalid API response");
        }

        // Check finish reason
        if (
            candidate.finishReason &&
            candidate.finishReason !== "STOP" &&
            candidate.finishReason !== "FINISH_REASON_UNSPECIFIED"
        ) {
            this.logError(
                "AnswerSetGenerator",
                `Generation stopped early: ${candidate.finishReason}`
            );
            throw new Error(`Generation stopped early: ${candidate.finishReason}`);
        }

        // Extract JSON payload
        const jsonText = this.extractJsonPayload(result);
        if (!jsonText) {
            this.logError("AnswerSetGenerator", "No response text from API");
            throw new Error("Invalid API response");
        }

        // Parse JSON
        let parsed: any;
        try {
            parsed = JSON.parse(jsonText);
        } catch (parseError) {
            this.logError("AnswerSetGenerator", "Failed to parse JSON response");
            throw new Error("Invalid JSON response from API");
        }

        // Validate structure
        if (!parsed || typeof parsed !== "object") {
            throw new Error("Invalid response structure");
        }

        if (!Array.isArray(parsed.correct) || !Array.isArray(parsed.close)) {
            throw new Error("Response missing required arrays");
        }

        // Filter out empty strings and normalize
        const correct = parsed.correct
            .filter((a: any) => typeof a === "string" && a.trim().length > 0)
            .map((a: string) => a.trim().toLowerCase());

        const close = parsed.close
            .filter((a: any) => typeof a === "string" && a.trim().length > 0)
            .map((a: string) => a.trim().toLowerCase());

        // Validate we have reasonable number of answers
        if (correct.length === 0) {
            this.logWarning("AnswerSetGenerator", "AI returned zero correct answers");
            throw new Error("No correct answers generated");
        }

        if (correct.length > 50 || close.length > 50) {
            this.logWarning("AnswerSetGenerator", "AI returned too many answers, truncating");
        }

        return {
            correct: correct.slice(0, 50), // Cap at 50
            close: close.slice(0, 50),
        };
    }

    /**
     * Extract JSON payload from Gemini response
     */
    private extractJsonPayload(result: any): string | undefined {
        const candidate = result?.candidates?.[0];
        const parts = candidate?.content?.parts;

        if (!Array.isArray(parts)) {
            return undefined;
        }

        for (const part of parts) {
            if (typeof part?.text === "string" && part.text.trim().length > 0) {
                return part.text;
            }

            const functionCall = part?.functionCall;
            if (functionCall?.args) {
                if (typeof functionCall.args === "string") {
                    return functionCall.args;
                }
                try {
                    return JSON.stringify(functionCall.args);
                } catch {
                    // Ignore and continue
                }
            }
        }

        return undefined;
    }

    /**
     * Generate a basic fallback answer set when AI fails
     * Uses simple string manipulation to create variations
     */
    getFallbackAnswerSet(challenge: ChallengeCreate | Challenge): AnswerSet {
        const answer = challenge.correct_answer.trim().toLowerCase();
        const words = answer.split(/\s+/);

        const correct: string[] = [answer];

        // Add simple variations
        // Plural/singular
        if (answer.endsWith("s")) {
            correct.push(answer.slice(0, -1)); // Remove 's'
        } else {
            correct.push(answer + "s"); // Add 's'
        }

        // Word order variations (if multiple words)
        if (words.length === 2) {
            correct.push(words.reverse().join(" "));
        }

        // Add tag-based close answers if available
        const close: string[] = [];
        if (challenge.tags && challenge.tags.length > 0) {
            close.push(...challenge.tags.map((tag) => tag.toLowerCase()));
        }

        // Deduplicate
        return {
            correct: [...new Set(correct)],
            close: [...new Set(close)],
        };
    }

    /**
     * Check if AI generation is configured
     */
    async isConfigured(): Promise<boolean> {
        try {
            const settings = await this.context.settings.getAll();
            const apiKey = settings["GEMINI_API_KEY"] as string;
            return !!apiKey;
        } catch (error) {
            this.logError("AnswerSetGenerator.isConfigured", error);
            return false;
        }
    }
}
