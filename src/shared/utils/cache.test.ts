/**
 * Property-based tests for CacheKeyBuilder
 * 
 * **Feature: performance-optimization, Property 8: Cache Keys Follow Namespace Format**
 * **Validates: Requirements 6.4**
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { CacheKeyBuilder, InvalidCacheKeyError } from './cache.js';

describe('CacheKeyBuilder Properties', () => {
  /**
   * **Feature: performance-optimization, Property 8: Cache Keys Follow Namespace Format**
   * 
   * *For any* cache key generated by the system, the key SHALL match the pattern
   * `{entity}:{identifier}` or `{entity}:{identifier}:{qualifier}` where entity,
   * identifier, and qualifier contain no colons.
   * 
   * **Validates: Requirements 6.4**
   */
  describe('Property 8: Cache Keys Follow Namespace Format', () => {
    // Arbitrary for valid key parts (strings without colons)
    const validKeyPart = fc.string().filter(s => !s.includes(':') && s.length > 0);

    it('should generate keys matching pattern {entity}:{identifier} for two-part keys', () => {
      fc.assert(
        fc.property(validKeyPart, validKeyPart, (entity, identifier) => {
          const key = CacheKeyBuilder.createKey(entity, identifier);
          
          // Key should match pattern {entity}:{identifier}
          const pattern = /^[^:]+:[^:]+$/;
          expect(pattern.test(key)).toBe(true);
          
          // Key should be exactly entity:identifier
          expect(key).toBe(`${entity}:${identifier}`);
        }),
        { numRuns: 100 }
      );
    });

    it('should generate keys matching pattern {entity}:{identifier}:{qualifier} for three-part keys', () => {
      fc.assert(
        fc.property(validKeyPart, validKeyPart, validKeyPart, (entity, identifier, qualifier) => {
          const key = CacheKeyBuilder.createKey(entity, identifier, qualifier);
          
          // Key should match pattern {entity}:{identifier}:{qualifier}
          const pattern = /^[^:]+:[^:]+:[^:]+$/;
          expect(pattern.test(key)).toBe(true);
          
          // Key should be exactly entity:identifier:qualifier
          expect(key).toBe(`${entity}:${identifier}:${qualifier}`);
        }),
        { numRuns: 100 }
      );
    });

    it('should reject entity containing colons', () => {
      fc.assert(
        fc.property(
          fc.string().filter(s => s.includes(':')),  // entity with colon
          validKeyPart,  // valid identifier
          (entity, identifier) => {
            expect(() => CacheKeyBuilder.createKey(entity, identifier))
              .toThrow(InvalidCacheKeyError);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should reject identifier containing colons', () => {
      fc.assert(
        fc.property(
          validKeyPart,  // valid entity
          fc.string().filter(s => s.includes(':')),  // identifier with colon
          (entity, identifier) => {
            expect(() => CacheKeyBuilder.createKey(entity, identifier))
              .toThrow(InvalidCacheKeyError);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should reject qualifier containing colons', () => {
      fc.assert(
        fc.property(
          validKeyPart,  // valid entity
          validKeyPart,  // valid identifier
          fc.string().filter(s => s.includes(':')),  // qualifier with colon
          (entity, identifier, qualifier) => {
            expect(() => CacheKeyBuilder.createKey(entity, identifier, qualifier))
              .toThrow(InvalidCacheKeyError);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should produce keys that can be parsed back to original parts', () => {
      fc.assert(
        fc.property(validKeyPart, validKeyPart, (entity, identifier) => {
          const key = CacheKeyBuilder.createKey(entity, identifier);
          const parsed = CacheKeyBuilder.parseKey(key);
          
          expect(parsed.entity).toBe(entity);
          expect(parsed.identifier).toBe(identifier);
          expect(parsed.qualifier).toBeUndefined();
        }),
        { numRuns: 100 }
      );
    });

    it('should produce three-part keys that can be parsed back to original parts', () => {
      fc.assert(
        fc.property(validKeyPart, validKeyPart, validKeyPart, (entity, identifier, qualifier) => {
          const key = CacheKeyBuilder.createKey(entity, identifier, qualifier);
          const parsed = CacheKeyBuilder.parseKey(key);
          
          expect(parsed.entity).toBe(entity);
          expect(parsed.identifier).toBe(identifier);
          expect(parsed.qualifier).toBe(qualifier);
        }),
        { numRuns: 100 }
      );
    });
  });
});
